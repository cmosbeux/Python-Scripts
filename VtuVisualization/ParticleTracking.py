#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Apr 28 11:10:52 2022

@author: cmosbeux
"""

import numpy as np
import matplotlib.pyplot as plt


# a function that calculates the indices of the 
# closest point from the mesh-grid to a given arbitrary point p
def indxs(p, x, y):
    i = np.int(x.shape[1]*(p[0] - x[0,0])/(x[0,-1] - x[0,0]))
    j = np.int(y.shape[0]*(p[1] - y[0,0])/(y[-1,0] - y[0,0]))
    return i, j


# a simple quadratic interpolation of the mesh-grid vector filed
# to a quadratically interpolated vector field at a point p inside 
# mesh-grid the square in which p is located
def VF(p, x, y, V):
    i, j = indxs(p, x, y)
    if 0 < i and i < x.shape[1]-1 and 0 < j and j < y.shape[0]-1: 
        a = ( p[0] - x[0, i] ) / (x[0, i+1] - x[0, i]) 
        b = ( p[1] - y[j, 0] ) / (y[j+1, 0] - y[j, 0])
        W = (1-a) * (1-b) * V[:, j, i]  +  (1-a) * b * V[:, j, i+1]
        W = W  +  a * (1-b) * V[:, j+1, i]  +  a * b * V[:, j+1, i+1]   
        return W #/ np.linalg.norm(W) # you can also normalize the vector field to get only the trajecotry, without accounting for parametrization
    else:
        return np.array([0.0, 0.0])


# integrating the vector field one time step 
# starting from a given point p
# uses Runge-Kutta 4 integrations, which 
# allows you to sample the vector fields at four different near-by points and 
# 'average' the result 
def VF_flow(p, x, y, V, t_step):
    k1 = VF(p, x, y, V)
    k2 = VF(p + t_step*k1/2, x, y, V)
    k3 = VF(p + t_step*k2/2, x, y, V)
    k4 = VF(p + t_step*k3, x, y, V)
    return p + t_step * (k1 + 2*k2 + 2*k3 + k4) / 6


def VF_trajectory(p, x, y, V, t_step, n_iter):
    traj = np.empty( (2, n_iter), dtype = float)
    traj[:, 0] = p
    #m = 0
    #while m < n_iter and (x[0,0] < traj[0,m]     traj[1,m]): 
    for m in range(n_iter-1):
        traj[:, m+1] = VF_flow(traj[:, m], x, y, V, t_step) 
        m = m+1
    return traj

# a function that 
def U(x, y):
    '''
    turns a planar polynomial vector field into a vector field on the mesh-grid
    '''
    return -x + 0.3*x*y + 0.7*y**2, -0.5*y + 0.2*x*y - 0.1*x**2


# Example 
def get_flow_line_test():
    
    '''
    You can run this example if you want to check the code.
    '''

    x_left = -8 
    x_right = 8
    y_bottom = -8
    y_top = 8

    N_points_x = 200
    N_points_y = 200
    
    # generate the mesh-gird
    x, y = np.meshgrid(np.linspace(x_left, x_right, N_points_x),np.linspace(y_bottom, y_top, N_points_y))
    
    # initialize an empty array for the values of the vector filed at each point from the mesh-grid
    V = np.empty((2, x.shape[1], y.shape[0]), dtype=float)
    
    # turns a planar polynomial vector field into a vector field on the mesh-grid
    V[0,:,:], V[1,:,:] = U(x, y)
    
    n_iterations = 700
    
    # initial point
    p0 = np.array([ -7.3, 3.1])
    #p0 = np.array([-3, 5])
    
    t_step = 0.005
    
    trajectory = VF_trajectory(p0 , x, y, V, t_step, n_iterations)
    
    # Stream plot internal to matplotlib
    plt.streamplot(x, y, V[0,:,:], V[1,:,:])
    # here I am plotting the trajectory generated by my functions on top of the plot of the 
    # flow-portrait of the mesh-grid vector field
    plt.plot(trajectory[0, :], trajectory[1, :], '-r')
    plt.axis('square')
    plt.axis([x_left, x_right, y_bottom, y_top])
    plt.show()